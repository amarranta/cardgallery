---
type LayoutMode = 'classic' | 'big-mobile';

interface RawTag {
  code?: string;
  slug?: string;
  label?: string;
}

interface RawMetadata {
  name?: string;
  author?: string;
  desc?: string;
}

interface RawItem {
  previewUrl?: string;
  gridUrl?: string;
  thumbUrl?: string;
  title?: string;
  description?: string;
  width?: number | string | null;
  height?: number | string | null;
  aspectRatio?: number | string | null;
  metadata?: RawMetadata | null;
  tagDetails?: RawTag[] | null;
}

interface LightboxTag {
  code: string;
  slug: string;
  label: string;
}

interface LightboxItem {
  preview: string;
  grid: string;
  thumb: string;
  title: string;
  description: string;
  name: string;
  author: string;
  desc: string;
  tags: LightboxTag[];
  width: number | null;
  height: number | null;
  aspectRatio: number | null;
}

interface ImageGridProps {
  items?: RawItem[];
  rowHeight?: number;
  layoutMode?: LayoutMode;
  gridId?: string | null;
}

const {
  items = [],
  rowHeight = 400,
  layoutMode = 'classic',
  gridId = null
} = Astro.props as ImageGridProps;

const normaliseTags = (tags: RawTag[] | null | undefined): LightboxTag[] =>
  Array.isArray(tags)
    ? tags
        .filter(tag => tag && (tag.slug || tag.code))
        .map(tag => ({
          code: tag.code ?? '',
          slug: tag.slug ?? '',
          label: tag.label ?? tag.code ?? tag.slug ?? ''
        }))
    : [];

const toPositiveNumber = (value: unknown): number | null => {
  const num = Number(value);
  return Number.isFinite(num) && num > 0 ? num : null;
};

const deriveAspectRatio = (
  aspect: unknown,
  width: number | null,
  height: number | null
): number | null => {
  const parsedAspect = Number(aspect);
  if (Number.isFinite(parsedAspect) && parsedAspect > 0) {
    return Number(parsedAspect.toFixed(5));
  }
  if (width && height) {
    const ratio = width / height;
    if (Number.isFinite(ratio) && ratio > 0) {
      return Number(ratio.toFixed(5));
    }
  }
  return null;
};

const normaliseItem = (item: RawItem | undefined): LightboxItem => {
  const width = toPositiveNumber(item?.width ?? null);
  const height = toPositiveNumber(item?.height ?? null);
  const aspectRatio = deriveAspectRatio(item?.aspectRatio ?? null, width, height);

  return {
    preview: item?.previewUrl ?? '',
    grid: item?.gridUrl ?? item?.thumbUrl ?? item?.previewUrl ?? '',
    thumb: item?.thumbUrl ?? '',
    title: item?.title ?? '',
    description: item?.description ?? '',
    name: item?.metadata?.name ?? '',
    author: item?.metadata?.author ?? '',
    desc: item?.metadata?.desc ?? '',
    tags: normaliseTags(item?.tagDetails ?? null),
    width,
    height,
    aspectRatio
  };
};

const serialiseItems = (source: LightboxItem[]): string => {
  if (!Array.isArray(source) || source.length === 0) return '';
  try {
    return encodeURIComponent(JSON.stringify(source));
  } catch (error) {
    console.warn('Failed to serialise lightbox items', error);
    return '';
  }
};

const normalisedItems: LightboxItem[] = items.map(item => normaliseItem(item));
const encodedItems = serialiseItems(normalisedItems);

---

<section
  id={gridId ?? undefined}
  class="section-shell"
  data-tone="ink"
  data-lightbox-root
  data-lightbox-base={import.meta.env.BASE_URL}
  data-lightbox-items={encodedItems}
  data-layout-mode={layoutMode}
>
  {normalisedItems.length === 0 ? (
    <p class="rounded-lg border border-dashed border-[var(--border-banner)] bg-[var(--surface-banner)] p-12 text-center text-sm text-[var(--text-banner)]">
      No images match this filter.
    </p>
  ) : (
    <>
      <div
        data-justified-grid
        data-row-height={rowHeight}
  data-row-gap="12"
        class="justified-grid"
      ></div>
      <div
        data-lightbox
  class="fixed inset-0 z-50 hidden flex items-center justify-center bg-[var(--surface-backdrop)] backdrop-blur-md px-5 py-8"
        aria-hidden="true"
      >
        <div class="relative flex h-full w-full max-w-6xl flex-col items-center justify-center">
          <button
            type="button"
            data-lightbox-close
            class="absolute right-3 top-3 z-20 flex h-12 w-12 items-center justify-center rounded-full border border-white/30 bg-[var(--surface-backdrop-strong)] text-white shadow-[0_16px_36px_var(--shadow-ink)] transition hover:scale-105 hover:bg-[var(--surface-backdrop-hover)] focus:outline-none focus:ring-4 focus:ring-white/70 sm:right-0 sm:top-0 sm:h-14 sm:w-14"
          >
            <span class="sr-only">Close lightbox</span>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="h-7 w-7">
              <path stroke-linecap="round" stroke-linejoin="round" d="M6 6l12 12M18 6l-12 12" />
            </svg>
          </button>
          <div class="flex w-full flex-nowrap items-center justify-center gap-4 sm:gap-7">
            <button
              type="button"
              data-lightbox-prev
              class="hidden h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-[var(--surface-backdrop-compact)] text-white shadow-[0_12px_28px_var(--shadow-ink-soft)] transition hover:scale-110 hover:bg-[var(--surface-backdrop-compact-hover)] focus:outline-none focus:ring-4 focus:ring-white/60 sm:flex"
            >
              <span class="sr-only">Previous image</span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="h-6 w-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
              </svg>
            </button>
            <figure class="flex flex-1 max-w-4xl flex-col items-center gap-6 text-center" data-lightbox-swipe>
              <div class="flex max-h-[75vh] w-full justify-center">
                <img data-lightbox-image src="" alt="" class="max-h-[75vh] w-auto max-w-full rounded-2xl object-contain shadow-[0_14px_40px_var(--shadow-card-strong)]" />
              </div>
              <figcaption class="flex w-full flex-col items-center gap-4 text-center">
                <h2 data-lightbox-name class="hidden text-2xl font-semibold tracking-tight text-[var(--text-lightbox-heading)] md:text-[1.75rem]"></h2>
                <p data-lightbox-author class="hidden italic text-[var(--text-lightbox-accent)]"></p>
                <p data-lightbox-desc class="hidden text-base text-[var(--text-lightbox-body)]"></p>
                <div data-lightbox-tags-wrapper class="hidden w-full text-center">
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-[var(--text-lightbox-accent)]">Tags</p>
                  <div data-lightbox-tags class="mt-2 flex flex-wrap justify-center gap-2"></div>
                </div>
              </figcaption>
            </figure>
            <button
              type="button"
              data-lightbox-next
              class="hidden h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-[var(--surface-backdrop-compact)] text-white shadow-[0_12px_28px_var(--shadow-ink-soft)] transition hover:scale-110 hover:bg-[var(--surface-backdrop-compact-hover)] focus:outline-none focus:ring-4 focus:ring-white/60 sm:flex"
            >
              <span class="sr-only">Next image</span>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="h-6 w-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </>
  )}
</section>
<script is:inline>
  /**
   * @typedef {'classic' | 'big-mobile'} LayoutModeValue
   */

  /**
   * @typedef {'single-landscape' | 'single-portrait' | 'pair-portrait'} MobileRowVariant
   */

  /**
   * @typedef {Object} LightboxTag
   * @property {string} code
   * @property {string} slug
   * @property {string} label
   */

  /**
   * @typedef {Object} LightboxItem
   * @property {string} preview
   * @property {string} grid
   * @property {string} thumb
   * @property {string} title
   * @property {string} description
   * @property {string} name
   * @property {string} author
   * @property {string} desc
   * @property {LightboxTag[]} tags
   * @property {number | null} width
   * @property {number | null} height
   * @property {number | null} aspectRatio
   */

  /**
   * @typedef {Object} MobileRowEntry
   * @property {LightboxItem} item
   * @property {number} index
   * @property {number} aspect
   */

  /**
   * @typedef {Object} MobileRow
   * @property {MobileRowVariant} variant
   * @property {MobileRowEntry[]} items
   */

  /**
   * @typedef {Object} SwipeState
   * @property {number} pointerId
   * @property {number} startX
   * @property {number} startY
   * @property {boolean} swiping
   */

  /**
   * @typedef {Object} SwipeTransformOptions
   * @property {boolean} [animate]
   */

  class JustifiedLightboxGallery {
    /**
     * @param {HTMLElement} root
     */
    constructor(root) {
      /** @type {HTMLElement} */
      this.root = root;

      const grid = root.querySelector('[data-justified-grid]');
      /** @type {HTMLElement | null} */
      this.gridEl = grid instanceof HTMLElement ? grid : null;

      const overlay = root.querySelector('[data-lightbox]');
      /** @type {HTMLElement | null} */
      this.overlay = overlay instanceof HTMLElement ? overlay : null;

      const overlayImage = this.overlay?.querySelector('[data-lightbox-image]');
      /** @type {HTMLImageElement | null} */
      this.imageEl = overlayImage instanceof HTMLImageElement ? overlayImage : null;

      const overlayName = this.overlay?.querySelector('[data-lightbox-name]');
      /** @type {HTMLElement | null} */
      this.nameEl = overlayName instanceof HTMLElement ? overlayName : null;

      const overlayDesc = this.overlay?.querySelector('[data-lightbox-desc]');
      /** @type {HTMLElement | null} */
      this.descEl = overlayDesc instanceof HTMLElement ? overlayDesc : null;

      const overlayAuthor = this.overlay?.querySelector('[data-lightbox-author]');
      /** @type {HTMLElement | null} */
      this.authorEl = overlayAuthor instanceof HTMLElement ? overlayAuthor : null;

      const overlayTagsWrapper = this.overlay?.querySelector('[data-lightbox-tags-wrapper]');
      /** @type {HTMLElement | null} */
      this.tagsWrapper = overlayTagsWrapper instanceof HTMLElement ? overlayTagsWrapper : null;

      const overlayTags = this.overlay?.querySelector('[data-lightbox-tags]');
      /** @type {HTMLElement | null} */
      this.tagsContainer = overlayTags instanceof HTMLElement ? overlayTags : null;

      const closeButton = this.overlay?.querySelector('[data-lightbox-close]');
      /** @type {HTMLButtonElement | null} */
      this.closeBtn = closeButton instanceof HTMLButtonElement ? closeButton : null;

      const nextButton = this.overlay?.querySelector('[data-lightbox-next]');
      /** @type {HTMLButtonElement | null} */
      this.nextBtn = nextButton instanceof HTMLButtonElement ? nextButton : null;

      const prevButton = this.overlay?.querySelector('[data-lightbox-prev]');
      /** @type {HTMLButtonElement | null} */
      this.prevBtn = prevButton instanceof HTMLButtonElement ? prevButton : null;

      /** @type {LightboxItem[]} */
      this.items = this.parseItems(root.dataset.lightboxItems);
      this.base = root.dataset.lightboxBase || '/';

      const modeFromDataset = root.dataset.layoutMode;
      /** @type {LayoutModeValue} */
      this.layoutMode = modeFromDataset === 'big-mobile' ? 'big-mobile' : 'classic';

      this.baseTargetHeight = Number(this.gridEl?.dataset.rowHeight) || 400;
      const rawGap = Number(this.gridEl?.dataset.rowGap);
      this.baseGap = Number.isFinite(rawGap) && rawGap >= 0 ? rawGap : 12;

      const overlaySwipe = this.overlay?.querySelector('[data-lightbox-swipe]');
      /** @type {HTMLElement | null} */
      this.swipeArea = overlaySwipe instanceof HTMLElement ? overlaySwipe : null;

      /** @type {SwipeState | null} */
      this.swipeState = null;
      this.swipeThreshold = 60;
      this.maxVerticalDelta = 80;
      /** @type {HTMLButtonElement[]} */
      this.triggers = [];
      this.activeIndex = 0;
      this.previousOverflow = '';
      /** @type {ResizeObserver | undefined} */
      this.resizeObserver = undefined;
      /** @type {MutationObserver | undefined} */
      this.attributeObserver = undefined;

      this.handleKeyDown = this.handleKeyDown.bind(this);
      this.handleOverlayClick = this.handleOverlayClick.bind(this);
      this.handleCloseClick = this.handleCloseClick.bind(this);
      this.handleNextClick = this.handleNextClick.bind(this);
      this.handlePrevClick = this.handlePrevClick.bind(this);
      this.handlePointerDown = this.handlePointerDown.bind(this);
      this.handlePointerMove = this.handlePointerMove.bind(this);
      this.handlePointerUp = this.handlePointerUp.bind(this);
      this.handlePointerCancel = this.handlePointerCancel.bind(this);

      if (!this.gridEl || this.items.length === 0) {
        return;
      }

      this.setupOverlayControls();
      this.renderGrid();

      if (typeof ResizeObserver !== 'undefined') {
        this.resizeObserver = new ResizeObserver(() => {
          this.renderGrid();
        });
        this.resizeObserver.observe(this.root);
      }

      if (typeof MutationObserver !== 'undefined') {
        this.attributeObserver = new MutationObserver(mutations => {
          for (const mutation of mutations) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-layout-mode') {
              const nextMode = this.root.dataset.layoutMode === 'big-mobile' ? 'big-mobile' : 'classic';
              if (nextMode !== this.layoutMode) {
                this.layoutMode = nextMode;
                this.renderGrid();
              }
            }
          }
        });
        this.attributeObserver.observe(this.root, {
          attributes: true,
          attributeFilter: ['data-layout-mode']
        });
      }
    }

    /**
     * @param {string | undefined} raw
     * @returns {LightboxItem[]}
     */
    parseItems(raw) {
      if (!raw) return [];
      try {
        const parsed = JSON.parse(decodeURIComponent(raw));
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.warn('Failed to parse justified gallery items', error);
        return [];
      }
    }

    /**
     * @param {LightboxItem} item
     * @returns {number}
     */
    getAspect(item) {
      const direct = item.aspectRatio;
      if (typeof direct === 'number' && Number.isFinite(direct) && direct > 0) {
        return direct;
      }
      const { width, height } = item;
      if (width && height && height > 0) {
        return width / height;
      }
      return 1.5;
    }

    /**
     * @param {number} containerWidth
     * @returns {number}
     */
    getResponsiveTargetHeight(containerWidth) {
      const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : containerWidth;
      const baseTarget = this.baseTargetHeight || 400;
      if (!Number.isFinite(baseTarget) || baseTarget <= 0) {
        return 400;
      }

      const smallLimit = Math.max(160, Math.min(baseTarget, 220));
      const mediumLimit = Math.max(200, Math.min(baseTarget, 280));
      const largeLimit = Math.max(240, Math.min(baseTarget, 340));

      if (viewportWidth <= 480 || containerWidth <= 480) {
        return smallLimit;
      }
      if (viewportWidth <= 768) {
        return mediumLimit;
      }
      if (viewportWidth <= 1024) {
        return largeLimit;
      }
      return baseTarget;
    }

    /**
     * @param {number} containerWidth
     * @returns {{ min: number, max: number }}
     */
    getResponsiveRowScale(containerWidth) {
      const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : containerWidth;
      if (viewportWidth <= 480 || containerWidth <= 480) {
        return { min: 0.55, max: 1.25 };
      }
      if (viewportWidth <= 768) {
        return { min: 0.6, max: 1.3 };
      }
      return { min: 0.7, max: 1.35 };
    }

    /**
     * @param {number} containerWidth
     * @returns {number}
     */
    getResponsiveGap(containerWidth) {
      const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : containerWidth;
      const baseGap = Number.isFinite(this.baseGap) ? this.baseGap : 12;
      if (viewportWidth <= 480 || containerWidth <= 480) {
        return Math.max(6, Math.min(baseGap, 8));
      }
      if (viewportWidth <= 768) {
        return Math.max(7, Math.min(baseGap, 10));
      }
      return baseGap;
    }

    renderGrid() {
      const grid = this.gridEl;
      if (!grid) return;

      const containerWidth = grid.clientWidth || grid.offsetWidth;
      if (!containerWidth) {
        requestAnimationFrame(() => this.renderGrid());
        return;
      }

      const gap = this.getResponsiveGap(containerWidth);
      grid.style.setProperty('--row-gap', `${gap}px`);
      grid.innerHTML = '';
      this.triggers = [];

      const items = this.items;
      const enableBigLayout = this.layoutMode === 'big-mobile';
      const isMobileLayout = enableBigLayout && containerWidth <= 640;
      grid.classList.toggle('is-mobile-big', isMobileLayout);

      if (isMobileLayout) {
        const mobileRows = this.buildMobileRows(items);
        mobileRows.forEach(row => {
          const rowEl = document.createElement('div');
          const baseClass = 'big-layout-row';
          const variantClass = `big-layout-row--${row.variant}`;
          const sizeClass = row.variant === 'pair-portrait' ? 'big-layout-row--pair' : 'big-layout-row--single';
          rowEl.className = `${baseClass} ${sizeClass} ${variantClass}`;

          row.items.forEach(entry => {
            const trigger = this.createTrigger(entry.item, entry.index);
            const orientation = entry.aspect >= 1 ? 'landscape' : 'portrait';
            trigger.classList.add('justified-item--big', `justified-item--${orientation}`);
            trigger.style.height = 'auto';
            trigger.style.width = '100%';
            trigger.style.flex = '0 0 auto';
            trigger.style.aspectRatio = String(entry.aspect);
            trigger.style.setProperty('--big-aspect', String(entry.aspect));
            rowEl.appendChild(trigger);
          });

          grid.appendChild(rowEl);
        });

        this.refreshNavVisibility();
        return;
      }

      const baseTargetHeight = this.getResponsiveTargetHeight(containerWidth);
      const { min: minScale, max: maxScale } = this.getResponsiveRowScale(containerWidth);

      /** @type {MobileRowEntry[]} */
      let currentRow = [];
      let aspectSum = 0;

      const flushRow = isLast => {
        if (currentRow.length === 0) return;

        const availableWidth = containerWidth - gap * (currentRow.length - 1);
        const idealHeight = availableWidth / aspectSum;
        const clampedHeight = Math.max(
          baseTargetHeight * minScale,
          Math.min(baseTargetHeight * maxScale, idealHeight)
        );
        const rowHeight = isLast ? baseTargetHeight : clampedHeight;

        const rowEl = document.createElement('div');
        rowEl.className = 'justified-row';
        rowEl.style.height = `${rowHeight}px`;
        if (isLast) {
          rowEl.classList.add('justified-row--last');
        }

        currentRow.forEach(entry => {
          const trigger = this.createTrigger(entry.item, entry.index);
          if (isLast) {
            trigger.style.flex = '0 0 auto';
            trigger.style.width = `${rowHeight * entry.aspect}px`;
            trigger.style.height = `${rowHeight}px`;
          } else {
            trigger.style.flex = `${entry.aspect} 1 0`;
            trigger.style.height = `${rowHeight}px`;
          }
          rowEl.appendChild(trigger);
        });

        grid.appendChild(rowEl);
        currentRow = [];
        aspectSum = 0;
      };

      items.forEach((item, index) => {
        const aspect = this.getAspect(item);
        currentRow.push({ item, aspect, index });
        aspectSum += aspect;
        const projectedWidth = aspectSum * baseTargetHeight + gap * (currentRow.length - 1);
        if (projectedWidth >= containerWidth) {
          flushRow(false);
        }
      });

      if (currentRow.length) {
        flushRow(true);
      }

      this.refreshNavVisibility();
    }

    /**
     * @param {number} value
     * @param {number} [fallback=1]
     * @returns {number}
     */
    clampAspect(value, fallback = 1) {
      if (!Number.isFinite(value) || value <= 0) {
        return fallback;
      }
      const rounded = Number(value.toFixed(5));
      return Math.min(2.6, Math.max(0.4, rounded));
    }

    /**
     * @param {LightboxItem[]} items
     * @returns {MobileRow[]}
     */
    buildMobileRows(items) {
      /** @type {MobileRow[]} */
      const rows = [];
      if (!Array.isArray(items) || items.length === 0) {
        return rows;
      }

      let index = 0;
      const total = items.length;

      while (index < total) {
        const currentItem = items[index];
        const currentAspectRaw = this.getAspect(currentItem);
        const currentAspect = this.clampAspect(currentAspectRaw, 1.25);
        const isLandscape = currentAspectRaw >= 1;

        if (isLandscape) {
          rows.push({
            variant: 'single-landscape',
            items: [{ item: currentItem, index, aspect: currentAspect }]
          });
          index += 1;
          continue;
        }

        /** @type {MobileRowEntry[]} */
        const portraitGroup = [];
        while (index < total) {
          const portraitItem = items[index];
          const portraitAspectRaw = this.getAspect(portraitItem);
          if (portraitAspectRaw >= 1) {
            break;
          }
          portraitGroup.push({
            item: portraitItem,
            index,
            aspect: this.clampAspect(portraitAspectRaw, 0.8)
          });
          index += 1;
        }

        let pointer = 0;
        while (pointer < portraitGroup.length) {
          const remaining = portraitGroup.length - pointer;
          if (remaining >= 2) {
            rows.push({
              variant: 'pair-portrait',
              items: [portraitGroup[pointer], portraitGroup[pointer + 1]]
            });
            pointer += 2;
          } else {
            rows.push({
              variant: 'single-portrait',
              items: [portraitGroup[pointer]]
            });
            pointer += 1;
          }
        }
      }

      return rows;
    }

    /**
     * @param {LightboxItem} item
     * @param {number} index
     * @returns {HTMLButtonElement}
     */
    createTrigger(item, index) {
      const button = document.createElement('button');
      button.type = 'button';
      button.dataset.lightboxTrigger = '';
      button.dataset.index = String(index);
      button.className = 'justified-item';
      const labelSource = item.name || item.title;
      const ariaLabel = labelSource ? `Open ${labelSource} in lightbox` : 'Open image in lightbox';
      button.setAttribute('aria-label', ariaLabel);

      const img = document.createElement('img');
      img.src = item.grid || item.preview || item.thumb;
      img.alt = item.name || item.title || 'Gallery image';
      img.loading = 'lazy';
      img.decoding = 'async';

      /**
       * @param {HTMLImageElement} image
       * @param {string} galleryBase
       */
      const attachFallback = (image, galleryBase) => {
        const baseRaw = galleryBase || '/';
        const baseWithSlash = baseRaw.endsWith('/') ? baseRaw : `${baseRaw}/`;
        const fallback = `${baseWithSlash}assets/img/unavailable.svg`;
        /**
         * @param {Event} event
         */
        const handleError = event => {
          const target = event.currentTarget;
          if (!(target instanceof HTMLImageElement) || target.dataset.fallbackApplied) return;
          target.dataset.fallbackApplied = '1';
          target.removeEventListener('error', handleError);
          target.src = fallback;
          target.alt = 'Not available';
          target.classList.add('is-fallback');
        };
        image.addEventListener('error', handleError);
      };

      attachFallback(img, this.base);
      button.appendChild(img);

      if (item.name || item.desc) {
        const overlay = document.createElement('div');
        overlay.className = 'justified-item__overlay';
        if (item.name) {
          const title = document.createElement('strong');
          title.className = 'justified-item__title';
          title.textContent = item.name;
          overlay.appendChild(title);
        }
        if (item.desc) {
          const description = document.createElement('p');
          description.className = 'justified-item__desc';
          description.textContent = item.desc;
          overlay.appendChild(description);
        }
        button.appendChild(overlay);
      }

      button.addEventListener('click', event => {
        event.preventDefault();
        this.openLightbox(index);
      });

      this.triggers[index] = button;
      return button;
    }

    setupOverlayControls() {
      if (!this.overlay) return;

      this.overlay.addEventListener('click', this.handleOverlayClick);
      this.closeBtn?.addEventListener('click', this.handleCloseClick);
      this.nextBtn?.addEventListener('click', this.handleNextClick);
      this.prevBtn?.addEventListener('click', this.handlePrevClick);
      if (this.swipeArea) {
        this.swipeArea.addEventListener('pointerdown', this.handlePointerDown);
        this.swipeArea.addEventListener('pointermove', this.handlePointerMove);
        this.swipeArea.addEventListener('pointerup', this.handlePointerUp);
        this.swipeArea.addEventListener('pointercancel', this.handlePointerCancel);
        this.swipeArea.addEventListener('pointerleave', this.handlePointerCancel);
      }
    }

    /**
     * @param {MouseEvent} event
     */
    handleOverlayClick(event) {
      if (event.target === this.overlay) {
        this.closeLightbox();
      }
    }

    /**
     * @param {MouseEvent} event
     */
    handleCloseClick(event) {
      event.preventDefault();
      this.closeLightbox();
    }

    /**
     * @param {MouseEvent} event
     */
    handleNextClick(event) {
      event.preventDefault();
      this.step(1);
    }

    /**
     * @param {MouseEvent} event
     */
    handlePrevClick(event) {
      event.preventDefault();
      this.step(-1);
    }

    /**
     * @param {PointerEvent} event
     */
    handlePointerDown(event) {
      if (!event.isPrimary || (event.pointerType === 'mouse' && event.button !== 0)) {
        return;
      }
      if (!this.swipeArea || !this.imageEl || this.overlay?.classList.contains('hidden')) {
        return;
      }
      this.swipeState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        swiping: false
      };
      this.swipeArea.style.cursor = 'grabbing';
      this.swipeArea.classList.add('is-touching');
      event.stopPropagation();
    }

    /**
     * @param {PointerEvent} event
     */
    handlePointerMove(event) {
      if (!this.swipeState || event.pointerId !== this.swipeState.pointerId) {
        return;
      }
      const deltaX = event.clientX - this.swipeState.startX;
      const deltaY = event.clientY - this.swipeState.startY;

      if (!this.swipeState.swiping) {
        if (Math.abs(deltaY) > this.maxVerticalDelta && Math.abs(deltaY) > Math.abs(deltaX)) {
          this.resetSwipeState();
          return;
        }
        if (Math.abs(deltaX) > 12) {
          this.swipeState.swiping = true;
        }
      }

      if (this.swipeState.swiping) {
        event.preventDefault();
        this.applySwipeTransform(deltaX);
      }
      event.stopPropagation();
    }

    /**
     * @param {PointerEvent} event
     */
    handlePointerUp(event) {
      if (!this.swipeState || event.pointerId !== this.swipeState.pointerId) {
        return;
      }
      const deltaX = event.clientX - this.swipeState.startX;
      if (this.swipeState.swiping && Math.abs(deltaX) >= this.swipeThreshold) {
        this.step(deltaX > 0 ? -1 : 1);
      }
      this.resetSwipeState();
      event.stopPropagation();
    }

    /**
     * @param {PointerEvent} event
     */
    handlePointerCancel(event) {
      if (!this.swipeState || event.pointerId !== this.swipeState.pointerId) {
        return;
      }
      this.resetSwipeState();
      event.stopPropagation();
    }

    /**
     * @param {number} deltaX
     * @param {SwipeTransformOptions} [options]
     */
    applySwipeTransform(deltaX, options = {}) {
      if (!this.imageEl) return;
      const { animate = false } = options;
      if (animate) {
        this.imageEl.style.transition = 'transform 0.18s ease-out';
      } else {
        this.imageEl.style.transition = 'transform 0s';
      }

      if (deltaX === 0) {
        this.imageEl.style.transform = 'translateX(0)';
      } else {
        const limited = Math.max(-160, Math.min(160, deltaX));
        this.imageEl.style.transform = `translateX(${limited}px)`;
      }

      if (animate) {
        window.setTimeout(() => {
          if (this.imageEl) {
            this.imageEl.style.transition = '';
          }
        }, 200);
      } else if (deltaX === 0) {
        this.imageEl.style.transition = '';
      }
    }

    resetSwipeState() {
      const shouldAnimate = Boolean(this.swipeState?.swiping);
      if (this.swipeArea) {
        this.swipeArea.style.cursor = '';
        this.swipeArea.classList.remove('is-touching');
      }
      this.applySwipeTransform(0, { animate: shouldAnimate });
      this.swipeState = null;
    }

    /**
     * @param {KeyboardEvent} event
     */
    handleKeyDown(event) {
      if (this.overlay?.classList.contains('hidden')) return;
      if (event.key === 'Escape') {
        event.preventDefault();
        this.closeLightbox();
      } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        this.step(1);
      } else if (event.key === 'ArrowLeft') {
        event.preventDefault();
        this.step(-1);
      }
    }

    refreshNavVisibility() {
      if (!this.nextBtn || !this.prevBtn) return;
      const shouldHide = this.items.length < 2;
      const toggleNav = button => {
        if (!button) return;
        if (shouldHide) {
          button.classList.add('sm:hidden');
          button.setAttribute('aria-hidden', 'true');
          button.setAttribute('tabindex', '-1');
        } else {
          button.classList.remove('sm:hidden');
          button.removeAttribute('aria-hidden');
          button.removeAttribute('tabindex');
        }
      };
      toggleNav(this.nextBtn);
      toggleNav(this.prevBtn);
    }

    /**
     * @param {LightboxTag[] | undefined} tags
     */
    renderTags(tags) {
      if (!this.tagsContainer || !this.tagsWrapper) return;
      const container = this.tagsContainer;
      const wrapper = this.tagsWrapper;
      container.innerHTML = '';
      const list = Array.isArray(tags) ? tags.filter(tag => tag && tag.slug) : [];
      if (list.length === 0) {
        wrapper.classList.add('hidden');
        return;
      }
      wrapper.classList.remove('hidden');
      const baseRaw = this.base || '/';
      const baseWithSlash = baseRaw.endsWith('/') ? baseRaw : `${baseRaw}/`;
      list.forEach(tag => {
        const anchor = document.createElement('a');
        anchor.href = `${baseWithSlash}tag/${tag.slug}`;
        anchor.textContent = `#${tag.label || tag.code || tag.slug}`;
        anchor.className = 'lightbox-tag';
        container.appendChild(anchor);
      });
    }

    updateOverlayContent() {
      const item = this.items[this.activeIndex];
      if (!item) return;

      const source = item.preview || item.grid || item.thumb;
      if (this.imageEl) {
        if (source) {
          if (this.imageEl.src !== source) {
            this.imageEl.src = source;
          }
        } else {
          this.imageEl.removeAttribute('src');
        }
        this.imageEl.alt = item.name || item.title || 'Gallery image';
        const baseRaw = this.base || '/';
        const baseWithSlash = baseRaw.endsWith('/') ? baseRaw : `${baseRaw}/`;
        const fallback = `${baseWithSlash}assets/img/unavailable.svg`;
        if (this.imageEl.dataset.fallbackHandlerAttached !== '1') {
          this.imageEl.dataset.fallbackHandlerAttached = '1';
          const handleOverlayError = event => {
            const target = event.currentTarget;
            if (!(target instanceof HTMLImageElement) || target.dataset.fallbackApplied) return;
            target.dataset.fallbackApplied = '1';
            target.removeEventListener('error', handleOverlayError);
            target.src = fallback;
            target.alt = 'Not available';
            target.classList.add('is-fallback');
          };
          this.imageEl.addEventListener('error', handleOverlayError);
        }
        this.imageEl.style.transform = 'translateX(0)';
        this.imageEl.style.transition = '';
      }

      if (this.nameEl) {
        if (item.name) {
          this.nameEl.textContent = item.name;
          this.nameEl.classList.remove('hidden');
        } else {
          this.nameEl.textContent = '';
          this.nameEl.classList.add('hidden');
        }
      }

      if (this.authorEl) {
        if (item.author) {
          this.authorEl.textContent = `by ${item.author}`;
          this.authorEl.classList.remove('hidden');
        } else {
          this.authorEl.textContent = '';
          this.authorEl.classList.add('hidden');
        }
      }

      if (this.descEl) {
        if (item.desc) {
          this.descEl.textContent = item.desc;
          this.descEl.classList.remove('hidden');
        } else {
          this.descEl.textContent = '';
          this.descEl.classList.add('hidden');
        }
      }

      this.renderTags(item.tags);
    }

    /**
     * @param {number} index
     */
    openLightbox(index) {
      if (!this.overlay || this.items.length === 0) return;
      this.activeIndex = index;
      this.updateOverlayContent();
      this.overlay.classList.remove('hidden');
      this.overlay.setAttribute('aria-hidden', 'false');
      this.previousOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      window.addEventListener('keydown', this.handleKeyDown);
      requestAnimationFrame(() => {
        this.closeBtn?.focus();
      });
    }

    closeLightbox() {
      if (!this.overlay || this.overlay.classList.contains('hidden')) return;
      this.overlay.classList.add('hidden');
      this.overlay.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = this.previousOverflow;
      window.removeEventListener('keydown', this.handleKeyDown);
      const trigger = this.triggers[this.activeIndex];
      if (trigger) {
        trigger.focus({ preventScroll: true });
      }
    }

    /**
     * @param {number} direction
     */
    step(direction) {
      if (this.items.length < 2) return;
      this.activeIndex = (this.activeIndex + direction + this.items.length) % this.items.length;
      this.updateOverlayContent();
    }
  }

  /** @type {HTMLElement[]} */
  const lightboxRoots = Array.from(document.querySelectorAll('[data-lightbox-root]'));
  lightboxRoots.forEach(root => {
    if (!(root instanceof HTMLElement)) return;
    const hasItems = Boolean(root.dataset.lightboxItems && root.dataset.lightboxItems.length > 0);
    if (hasItems) {
      new JustifiedLightboxGallery(root);
    }
  });
</script>
<style is:global>
  .justified-grid {
    display: flex;
    flex-direction: column;
    gap: var(--row-gap, 12px);
  }

  .justified-row {
    display: flex;
    gap: var(--row-gap, 12px);
    justify-content: flex-start;
  }

  .justified-row--last {
    flex-wrap: nowrap;
  }

  .justified-item {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  border: 1px solid var(--border-lightbox);
  border-radius: 0;
  background: transparent;
  box-shadow: 0 8px 20px var(--shadow-lightbox);
  transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s ease-out;
    cursor: pointer;
    padding: 0;
    overflow: hidden;
  }

  .justified-item:hover {
  transform: translateY(-4px);
  box-shadow: 0 18px 36px var(--shadow-card-lift);
  border-color: var(--border-lightbox-strong);
  }

  .justified-item:focus-visible {
  outline: 3px solid var(--state-focus-toggle);
    outline-offset: 2px;
  }

  .justified-item img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  background: transparent;
  }

  .justified-grid.is-mobile-big {
    gap: var(--row-gap, 12px);
  }

  .justified-grid.is-mobile-big .big-layout-row {
    display: flex;
    flex-direction: column;
    gap: var(--row-gap, 12px);
  }

  .justified-grid.is-mobile-big .big-layout-row--pair {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: var(--row-gap, 12px);
  }

  .justified-grid.is-mobile-big .big-layout-row--single {
    display: block;
  }

  .justified-grid.is-mobile-big .justified-item--big {
    display: block;
    width: 100%;
    height: auto;
    aspect-ratio: var(--big-aspect, 1.2);
    border-radius: 0.85rem;
  border: 1px solid var(--border-lightbox);
    background: transparent;
  box-shadow: 0 12px 28px var(--shadow-lightbox-soft);
    padding: 0;
    cursor: pointer;
  }

  .justified-grid.is-mobile-big .justified-item--big img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .justified-grid.is-mobile-big .justified-item--portrait {
    aspect-ratio: var(--big-aspect, 0.75);
  }

  .justified-grid.is-mobile-big .justified-item--landscape {
    aspect-ratio: var(--big-aspect, 1.5);
  }

  .justified-grid.is-mobile-big .justified-item--big:hover {
    transform: translateY(-4px);
  box-shadow: 0 16px 34px var(--shadow-lightbox-strong);
  border-color: var(--border-lightbox-lift);
  }

  .justified-grid.is-mobile-big .justified-item--big:focus-visible {
  outline: 3px solid var(--state-focus-toggle);
    outline-offset: 3px;
  }

  /* Style for images replaced by the fallback placeholder */
  .justified-item img.is-fallback {
    object-fit: cover;
    background: var(--surface-fallback);
    color: var(--text-fallback);
  }

  .justified-item__overlay {
    position: absolute;
    inset: auto 0 0;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    padding: 1rem 1.15rem;
  background: linear-gradient(to bottom, var(--overlay-gradient-start), var(--overlay-gradient-end));
  color: var(--text-lightbox-base);
    font-size: 0.85rem;
    opacity: 0;
    transition: opacity 0.2s ease-out;
    pointer-events: none;
  }

  .justified-item:hover .justified-item__overlay,
  .justified-item:focus-visible .justified-item__overlay {
    opacity: 1;
  }

  @media (max-width: 640px) {
    .justified-item {
  box-shadow: 0 6px 14px var(--shadow-card-soft);
    }

    .justified-item:hover {
      transform: translateY(-4px);
  box-shadow: 0 16px 26px var(--shadow-banner);
    }
  }

  .justified-item__title {
    font-size: 0.98rem;
    font-weight: 600;
  color: var(--text-lightbox-title);
  }

  .justified-item__desc {
  color: var(--text-lightbox-body);
    line-height: 1.4;
  }

  .lightbox-tag {
    display: inline-flex;
    align-items: center;
    border-radius: 9999px;
  border: 1px solid var(--border-tag-pill);
  background: var(--surface-tag);
    padding: 0.25rem 0.8rem;
    font-size: 0.875rem;
    font-weight: 600;
  color: var(--text-lightbox-link);
    transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease;
  }

  .lightbox-tag:hover {
    transform: translateY(-2px);
  background: var(--surface-tag-hover);
  border-color: var(--border-tag-pill-hover);
  }

  [data-lightbox-swipe] {
    width: 100%;
    touch-action: pan-y;
    cursor: grab;
  }

  [data-lightbox-swipe].is-touching {
    cursor: grabbing;
  }
</style>
