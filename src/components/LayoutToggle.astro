---
type LayoutModeId = 'classic' | 'big-mobile';

interface LayoutToggleProps {
  targetId?: string;
  defaultMode?: LayoutModeId;
}

interface LayoutToggleOption {
  id: LayoutModeId;
  label: string;
  icon: 'classic' | 'big';
}

const {
  targetId,
  defaultMode = 'classic'
} = Astro.props as LayoutToggleProps;

const modes: LayoutToggleOption[] = [
  {
    id: 'classic',
    label: 'Classic layout',
    icon: 'classic'
  },
  {
    id: 'big-mobile',
    label: 'Big mobile layout',
    icon: 'big'
  }
];
---
<div
  class="layout-toggle"
  data-layout-toggle
  data-target={targetId ?? ''}
  data-default={defaultMode}
>
  {modes.map(mode => (
    <button
      type="button"
      class="layout-toggle__button"
      data-mode={mode.id}
      aria-pressed="false"
    >
      <span class="layout-toggle__icon" aria-hidden="true">
        {mode.icon === 'classic' ? (
          <svg width="28" height="22" viewBox="0 0 28 22" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="1" y="1" width="9" height="8" rx="2" fill="currentColor" />
            <rect x="12" y="1" width="7" height="3.5" rx="1.5" fill="currentColor" />
            <rect x="21" y="1" width="6" height="5.5" rx="1.5" fill="currentColor" />
            <rect x="12" y="6" width="6.5" height="3" rx="1.5" fill="currentColor" />
            <rect x="1" y="12" width="6" height="8" rx="2" fill="currentColor" />
            <rect x="9" y="12" width="9" height="8" rx="2" fill="currentColor" />
            <rect x="20" y="12" width="7" height="8" rx="2" fill="currentColor" />
          </svg>
        ) : (
          <svg width="28" height="22" viewBox="0 0 28 22" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="1" y="1" width="16" height="9" rx="2" fill="currentColor" />
            <rect x="19" y="1" width="8" height="9" rx="2" fill="currentColor" />
            <rect x="1" y="12" width="11" height="9" rx="2" fill="currentColor" />
            <rect x="14" y="12" width="13" height="9" rx="2" fill="currentColor" />
          </svg>
        )}
      </span>
      <span class="layout-toggle__sr-only">{mode.label}</span>
    </button>
  ))}
</div>
<script>
  // @ts-nocheck
  (() => {
    const storageKey = 'cardgallery-layout-mode';
    /** @type {WeakSet<HTMLElement>} */
    const initialised = new WeakSet();

    /**
     * @param {HTMLButtonElement[]} buttons
     * @param {string} mode
     */
    const updateButtonState = (buttons, mode) => {
      buttons.forEach(btn => {
        const isActive = btn.dataset.mode === mode;
        btn.classList.toggle('is-active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    };

    /**
     * @param {string} id
     * @param {HTMLElement | null} fallback
     * @returns {HTMLElement | null}
     */
    const resolveTarget = (id, fallback) => {
      if (fallback && fallback.id === id && document.body.contains(fallback)) {
        return fallback;
      }
      return document.getElementById(id);
    };

    /**
     * @param {HTMLElement} root
     */
    const setupToggle = root => {
      if (!(root instanceof HTMLElement) || initialised.has(root)) return;

      const targetId = root.dataset.target ?? '';
      const defaultMode = root.dataset.default ?? 'classic';
      /** @type {HTMLButtonElement[]} */
      const buttons = Array.from(root.querySelectorAll('[data-mode]')).filter(
        (element): element is HTMLButtonElement => element instanceof HTMLButtonElement
      );
      if (!targetId || buttons.length === 0) return;

      const availableModes = new Set(
        buttons
          .map(btn => btn.dataset.mode)
          .filter((mode): mode is string => typeof mode === 'string' && mode.length > 0)
      );

      /** @type {HTMLElement | null} */
      let target = resolveTarget(targetId, null);
      /** @type {string | null} */
      let queuedMode = null;

      /**
       * @param {string | null | undefined} mode
       */
      const applyMode = mode => {
        const requested = typeof mode === 'string' && availableModes.has(mode) ? mode : defaultMode;
        updateButtonState(buttons, requested);
        queuedMode = requested;
        target = resolveTarget(targetId, target);
        if (!target) {
          return;
        }
        queuedMode = null;
        if (target.dataset.layoutMode !== requested) {
          target.dataset.layoutMode = requested;
        }
        try {
          localStorage.setItem(storageKey, requested);
        } catch (error) {
          /* ignore storage errors */
        }
      };

      let initialMode = defaultMode;
      try {
        const stored = localStorage.getItem(storageKey);
        if (stored && availableModes.has(stored)) {
          initialMode = stored;
        }
      } catch (error) {
        /* ignore storage errors */
      }

      buttons.forEach(btn => {
        btn.addEventListener('click', event => {
          event.preventDefault();
          applyMode(btn.dataset.mode);
        });
      });

      if (!target) {
        const observer = new MutationObserver(() => {
          target = resolveTarget(targetId, target);
          if (target) {
            observer.disconnect();
            const modeToApply = queuedMode || initialMode;
            applyMode(modeToApply);
          }
        });
        observer.observe(document.documentElement, {
          childList: true,
          subtree: true
        });
      }

      applyMode(initialMode);
      initialised.add(root);
    };

    const initialiseAll = () => {
      document
        .querySelectorAll('[data-layout-toggle]')
        .forEach(root => {
          if (root instanceof HTMLElement) {
            setupToggle(root);
          }
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialiseAll, { once: true });
    } else {
      initialiseAll();
    }

    document.addEventListener('astro:page-load', initialiseAll);
    document.addEventListener('astro:after-swap', initialiseAll);
  })();
</script>
<style>
  .layout-toggle {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.35rem;
    border-radius: 999px;
    border: 1px solid var(--border-toggle);
    background: var(--surface-toggle);
    box-shadow: var(--shadow-surface);
  }

  .layout-toggle__button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2.5rem;
    height: 2.1rem;
    border-radius: 0.65rem;
    border: 1px solid transparent;
    background: transparent;
  color: var(--text-toggle);
    transition: background 0.18s ease-out, color 0.18s ease-out, border-color 0.18s ease-out, transform 0.18s ease-out;
    cursor: pointer;
  }

  .layout-toggle__button:hover {
    transform: translateY(-1px);
    border-color: var(--border-toggle-hover);
    color: var(--text-toggle-strong);
  }

  .layout-toggle__button:focus-visible {
    outline: 3px solid var(--state-focus-toggle);
    outline-offset: 2px;
  }

  .layout-toggle__button.is-active {
    background: var(--brand-toggle);
    color: var(--text-toggle-on);
    border-color: var(--border-toggle-active);
  }

  .layout-toggle__icon {
    display: inline-flex;
  }

  .layout-toggle__sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @media (min-width: 1024px) {
    .layout-toggle {
      display: none;
    }
  }
</style>
